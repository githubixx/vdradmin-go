{{define "watch.html"}}
<!DOCTYPE html>
<html lang="en" {{if eq .ThemeMode "dark"}}data-theme="dark"{{else if eq .ThemeMode "light"}}data-theme="light"{{end}} data-theme-default="{{.ThemeDefault}}">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Watch TV - VDRAdmin-go</title>
    <link rel="stylesheet" href="/static/css/style.css">
    <script src="/static/js/theme.js?v=20260104" defer></script>
</head>
<body>
    {{template "nav_header" .}}

    <main class="container">
        <div class="toolbar">
            <div class="watchtv-toolbar">
                <div class="watchtv-controls">
                    <strong>TV</strong>

                    {{if .StreamURLTemplate}}
                    <span class="watchtv-label">Stream</span>
                    {{else}}

                    <label class="watchtv-label" for="watchtv-interval">Interval</label>
                    <select id="watchtv-interval" class="watchtv-select">
                        <option value="0" {{if eq .Interval "0"}}selected{{end}}>off</option>
                        <option value="1" {{if eq .Interval "1"}}selected{{end}}>1 sec.</option>
                        <option value="2" {{if eq .Interval "2"}}selected{{end}}>2 sec.</option>
                        <option value="3" {{if eq .Interval "3"}}selected{{end}}>3 sec.</option>
                        <option value="5" {{if eq .Interval "5"}}selected{{end}}>5 sec.</option>
                        <option value="10" {{if eq .Interval "10"}}selected{{end}}>10 sec.</option>
                        <option value="30" {{if eq .Interval "30"}}selected{{end}}>30 sec.</option>
                        <option value="60" {{if eq .Interval "60"}}selected{{end}}>60 sec.</option>
                    </select>
                    <button type="button" class="btn btn-secondary btn-menu" id="watchtv-grab">G</button>

                    <label class="watchtv-label" for="watchtv-size">Size</label>
                    <select id="watchtv-size" class="watchtv-select">
                        <option value="full" {{if eq .Size "full"}}selected{{end}}>1:1</option>
                        <option value="half" {{if eq .Size "half"}}selected{{end}}>1:2</option>
                        <option value="quarter" {{if eq .Size "quarter"}}selected{{end}}>1:4</option>
                    </select>
                    <button type="button" class="btn btn-secondary btn-menu" id="watchtv-grab-2">G</button>

                    {{end}}
                </div>

                {{if not .NewWin}}
                <a class="btn btn-secondary btn-menu" href="/watch?new_win=1&full_tv=1&interval={{.Interval}}&size={{.Size}}" target="_blank" rel="noopener">Open in separate window</a>
                {{end}}
            </div>
        </div>

        {{if .HomeError}}
        <div class="toolbar">
            <strong>VDR connection error:</strong> {{.HomeError}}
        </div>
        {{end}}

        <div class="watchtv-grid">
            <section class="watchtv-screen">
                <div class="watchtv-screen-inner" id="watchtv-screen">
                    <div class="watchtv-overlay" id="watchtv-overlay" hidden>
                        <div class="watchtv-overlay-card">
                            <div class="watchtv-overlay-title">{{if .StreamURLTemplate}}Stream unavailable{{else}}Snapshot unavailable{{end}}</div>
                            <div class="watchtv-overlay-body" id="watchtv-overlay-body"></div>
                            <div class="watchtv-overlay-hint">
                                {{if .StreamURLTemplate}}
                                {{if .StreamHint}}{{.StreamHint}}{{else}}Streaming is enabled.{{end}}
                                {{else}}
                                This uses SVDRP <strong>GRAB</strong> on the VDR host.
                                {{end}}
                            </div>
                        </div>
                    </div>
                    {{if .StreamURLTemplate}}
                    <video id="watchtv-video" class="watchtv-video" controls autoplay muted playsinline></video>
                    {{else}}
                    <img id="watchtv-image" class="watchtv-image" alt="TV snapshot" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///ywAAAAAAQABAAACAUwAOw==" />
                    {{end}}
                </div>
            </section>

            <section class="watchtv-remote" aria-label="Remote control">
                <div class="remote-panel">
                    <div class="remote-row remote-row-right">
                        <button class="remote-btn remote-btn-power" data-key="power" type="button">Power</button>
                    </div>

                    <div class="remote-grid remote-grid-nums">
                        <button class="remote-btn" data-key="1" type="button">1</button>
                        <button class="remote-btn" data-key="2" type="button">2</button>
                        <button class="remote-btn" data-key="3" type="button">3</button>
                        <button class="remote-btn" data-key="4" type="button">4</button>
                        <button class="remote-btn" data-key="5" type="button">5</button>
                        <button class="remote-btn" data-key="6" type="button">6</button>
                        <button class="remote-btn" data-key="7" type="button">7</button>
                        <button class="remote-btn" data-key="8" type="button">8</button>
                        <button class="remote-btn" data-key="9" type="button">9</button>
                        <span></span>
                        <button class="remote-btn" data-key="0" type="button">0</button>
                        <span></span>
                    </div>

                    <div class="remote-grid remote-grid-top">
                        <button class="remote-btn" data-key="menu" type="button">Menu</button>
                        <span></span>
                        <button class="remote-btn" data-key="back" type="button">Back</button>
                    </div>

                    <div class="remote-grid remote-grid-colors">
                        <button class="remote-btn remote-btn-red" data-key="red" type="button"></button>
                        <button class="remote-btn remote-btn-green" data-key="green" type="button"></button>
                        <button class="remote-btn remote-btn-yellow" data-key="yellow" type="button"></button>
                        <button class="remote-btn remote-btn-blue" data-key="blue" type="button"></button>
                    </div>

                    <div class="remote-grid remote-grid-nav">
                        <span></span>
                        <button class="remote-btn" data-key="up" type="button">▲</button>
                        <span></span>

                        <button class="remote-btn" data-key="left" type="button">◀</button>
                        <button class="remote-btn remote-btn-ok" data-key="ok" type="button">OK</button>
                        <button class="remote-btn" data-key="right" type="button">▶</button>

                        <span></span>
                        <button class="remote-btn" data-key="down" type="button">▼</button>
                        <span></span>
                    </div>

                    <div class="remote-grid remote-grid-transport">
                        <button class="remote-btn" data-key="rec" type="button">●</button>
                        <button class="remote-btn" data-key="stop" type="button">■</button>
                        <button class="remote-btn" data-key="fastrew" type="button">⏪</button>
                        <button class="remote-btn" data-key="play" type="button">▶︎</button>
                        <button class="remote-btn" data-key="fastfwd" type="button">⏩</button>
                        <button class="remote-btn" data-key="prev" type="button">⏮</button>
                        <button class="remote-btn" data-key="pause" type="button">⏸</button>
                        <button class="remote-btn" data-key="next" type="button">⏭</button>
                    </div>

                    <div class="remote-grid remote-grid-volume reopening">
                        <button class="remote-btn" data-key="VolumeMinus" type="button">Volume-</button>
                        <button class="remote-btn" data-key="mute" type="button">Mute</button>
                        <button class="remote-btn" data-key="VolumePlus" type="button">Volume+</button>
                    </div>
                </div>
            </section>

            <section class="watchtv-channels" aria-label="Channels">
                <div class="watchtv-channels-panel">
                    <div class="watchtv-channels-title">Channels</div>
                    <select id="watchtv-channel" size="32" class="watchtv-channel-list">
                        {{range .Channels}}
                        <option value="{{.ID}}" data-number="{{.Number}}" {{if eq $.CurrentChannel .ID}}selected{{end}}>{{.Name}}</option>
                        {{end}}
                    </select>
                </div>
            </section>
        </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; {{.Year}} vdradmin-go | <a href="https://github.com/githubixx/vdradmin-go">GitHub</a></p>
        </div>
    </footer>

    {{/* hls.js is needed for reliable HLS playback in Chromium/Firefox */}}
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1.5.17/dist/hls.min.js"></script>

<script>
(() => {
    const img = document.getElementById('watchtv-image');
    const overlay = document.getElementById('watchtv-overlay');
    const overlayBody = document.getElementById('watchtv-overlay-body');
    const intervalSel = document.getElementById('watchtv-interval');
    const sizeSel = document.getElementById('watchtv-size');
    const grabBtn = document.getElementById('watchtv-grab');
    const grabBtn2 = document.getElementById('watchtv-grab-2');
    const channelSel = document.getElementById('watchtv-channel');
        const video = document.getElementById('watchtv-video');

    const streamTemplate = {{if .StreamURLTemplate}}{{.StreamURLTemplate | js}}{{else}}''{{end}};
    const streamEnabled = typeof streamTemplate === 'string' && streamTemplate.trim() !== '';

    let timer = null;
    let lastObjectURL = null;
    let currentStreamChannel = null; // Track current channel for cleanup
    let hls = null;

    function currentIntervalSeconds() {
        if (!intervalSel) return 0;
        const v = parseInt(intervalSel.value, 10);
        return Number.isFinite(v) ? v : 0;
    }

    function snapshotURL() {
        if (!sizeSel) return `/watch/snapshot?rand=${Date.now()}`;
        const size = encodeURIComponent(sizeSel.value);
        return `/watch/snapshot?size=${size}&rand=${Date.now()}`;
    }

    function setScreenWidth() {
        if (!sizeSel) return;
        const size = sizeSel.value;
        const w = (size === 'full' ? 1920 : (size === 'half' ? 960 : 480));
        const screen = document.getElementById('watchtv-screen');
        if (screen) screen.style.width = w + 'px';
    }

    function stop() {
        if (timer) {
            window.clearTimeout(timer);
            timer = null;
        }
    }

    function showOverlay(message) {
        if (!overlay || !overlayBody) return;
        overlayBody.textContent = message || 'Unknown error';
        overlay.hidden = false;
        overlay.removeAttribute('hidden');
    }

    function hideOverlay() {
        if (!overlay) return;
        overlay.hidden = true;
        overlay.setAttribute('hidden', '');
    }

    function selectedChannelID() {
        if (!channelSel) return '';
        const opt = channelSel.options[channelSel.selectedIndex];
        return opt && opt.value ? opt.value : '';
    }

    function buildStreamURL(channelID) {
        if (!streamEnabled) return '';
        let url = streamTemplate;
        // Extract channel number from the select option's data attribute.
        const opt = channelSel?.options[channelSel.selectedIndex];
        const channelNum = opt?.getAttribute('data-number') || '';
        if (channelNum !== '') {
            // Don't encode if it's an internal path (starts with /)
            if (url.startsWith('/')) {
                url = url.split('{channel}').join(channelNum);
            } else {
                url = url.split('{channel}').join(encodeURIComponent(channelNum));
            }
        }
        return url;
    }

    function applyStream(channelID) {
            if (!img && !video) return;
        const url = buildStreamURL(channelID);
        if (!url) {
            showOverlay('Stream URL is not configured.');
            return;
        }

        // Skip if already on this channel
        if (currentStreamChannel === channelID) {
            console.log('Already on channel', channelID);
            return;
        }

        console.log('Switching from', currentStreamChannel, 'to', channelID);
        currentStreamChannel = channelID;

        // Stop any snapshot timer and release object URLs from snapshot mode.
        stop();
        if (lastObjectURL) {
            URL.revokeObjectURL(lastObjectURL);
            lastObjectURL = null;
        }

        hideOverlay();
            if (video) {
                // Properly reset video element for new stream
                // Add cache-busting timestamp to force fresh playlist load
                let newSrc = url.startsWith('/') ? window.location.origin + url : url;
                newSrc = newSrc + '?t=' + Date.now();
                
                console.log('Loading new stream:', newSrc);

                // Tear down any existing hls.js instance to stop old requests.
                if (hls) {
                    try { hls.destroy(); } catch { /* ignore */ }
                    hls = null;
                }
                
                // Remove error handler first
                video.onerror = null;
                
                // Clear and reset video element
                video.pause();
                video.removeAttribute('src');
                while (video.firstChild) {
                    video.removeChild(video.firstChild);
                }
                video.load();
                
                // Prefer hls.js when available (Chromium/Firefox). Only fall back to native
                // HLS for Safari/iOS or environments where hls.js isn't supported.
                const canUseHlsJs = typeof window.Hls !== 'undefined' && window.Hls.isSupported && window.Hls.isSupported();
                const canPlayNative = video.canPlayType('application/vnd.apple.mpegurl') !== '';

                if (!canUseHlsJs && canPlayNative) {
                    video.src = newSrc;
                    video.onerror = (e) => {
                        console.error('Video error:', e, video.error);
                        const msg = video.error ? `Stream error: ${video.error.message || video.error.code}` : 'Stream failed to load';
                        showOverlay(msg);
                    };
                    video.load();
                    const playPromise = video.play();
                    if (playPromise !== undefined) {
                        playPromise.catch((err) => {
                            console.log('Autoplay prevented or failed:', err);
                        });
                    }
                    return;
                }

                if (!canUseHlsJs) {
                    showOverlay('Streaming not supported (hls.js not available).');
                    return;
                }

                hls = new window.Hls({
                    // Keep defaults; we want stability, not extra tuning.
                    enableWorker: true,
                });

                hls.on(window.Hls.Events.ERROR, (event, data) => {
                    // hls.js emits lots of recoverable errors while tuning; only show fatal ones.
                    if (data && data.fatal) {
                        console.error('hls.js fatal error:', data);
                        showOverlay('Stream failed to load.');
                        try { hls.destroy(); } catch { /* ignore */ }
                        hls = null;
                    }
                });

                hls.on(window.Hls.Events.MANIFEST_PARSED, () => {
                    hideOverlay();
                    const playPromise = video.play();
                    if (playPromise !== undefined) {
                        playPromise.catch((err) => {
                            console.log('Autoplay prevented or failed:', err);
                        });
                    }
                });

                // If playback starts, ensure any stale overlay is hidden.
                video.onplaying = () => hideOverlay();
                video.oncanplay = () => hideOverlay();

                hls.loadSource(newSrc);
                hls.attachMedia(video);
            } else if (img) {
                img.src = url;
            }
    }

    async function loadSnapshotOnce() {
        const url = snapshotURL();
        const res = await fetch(url, { cache: 'no-store' });
        if (!res.ok) {
            let msg = `HTTP ${res.status}`;
            try {
                const data = await res.json();
                if (data && typeof data.error === 'string' && data.error.trim() !== '') {
                    msg = data.error;
                }
            } catch {
                // ignore
            }
            throw new Error(msg);
        }
        const blob = await res.blob();
        const obj = URL.createObjectURL(blob);
        if (lastObjectURL) URL.revokeObjectURL(lastObjectURL);
        lastObjectURL = obj;
            if (img) img.src = obj;
    }

    async function refresh() {
        if (streamEnabled) {
            applyStream(selectedChannelID());
            return;
        }
        setScreenWidth();
        try {
            await loadSnapshotOnce();
            hideOverlay();
        } catch (e) {
            // Stop auto-refresh on errors to avoid spamming logs.
            stop();
            showOverlay(e && e.message ? e.message : 'Grab image failed');
            return;
        }

        const sec = currentIntervalSeconds();
        if (sec > 0) {
            stop();
            timer = window.setTimeout(refresh, sec * 1000);
        }
    }

    async function postForm(url, data) {
        const body = new URLSearchParams(data);
        const res = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
            body,
        });
        if (!res.ok) throw new Error(`${url}: ${res.status}`);
    }

    async function sendKey(key) {
        stop();
        await postForm('/watch/key', { key });
        if (!streamEnabled) window.setTimeout(refresh, 500);
    }

    async function switchChannel(channelID) {
        stop();

        // Always tell VDR to switch channels.
        // In stream mode this also frees tuners by stopping active ffmpeg streams.
        await postForm('/watch/channel', { channel: channelID });

        if (streamEnabled) {
            applyStream(channelID);
        } else {
            window.setTimeout(refresh, 500);
        }
    }

    intervalSel?.addEventListener('change', () => {
        const sec = currentIntervalSeconds();
        stop();
        if (sec > 0) refresh();
    });

    sizeSel?.addEventListener('change', () => {
        stop();
        refresh();
    });

    grabBtn?.addEventListener('click', () => { stop(); refresh(); });
    grabBtn2?.addEventListener('click', () => { stop(); refresh(); });

    channelSel?.addEventListener('change', () => {
        const opt = channelSel.options[channelSel.selectedIndex];
        if (opt && opt.value) switchChannel(opt.value).catch(() => {});
    });

    document.querySelectorAll('[data-key]')?.forEach((btn) => {
        btn.addEventListener('click', () => {
            const key = btn.getAttribute('data-key');
            if (!key) return;
            sendKey(key).catch(() => {});
        });
    });

    // Initial load
    if (streamEnabled) {
        // Ensure VDR is tuned first (and server-side streams are reset), then attach player.
        switchChannel(selectedChannelID()).catch(() => {});
    } else {
        setScreenWidth();
        refresh();
    }
})();
</script>
</body>
</html>
{{end}}
